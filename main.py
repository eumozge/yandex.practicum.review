"""
Коментарии для проверяющего.

Код немного вырван из контекста, по ТЗ там целый проект и вроде как даже
есть тесты к написанному коду, но не уверен, по крайне мере в инструкции
есть дока по запуску тестов. Посмотреть весь проект помогло бы сделать ревю
менее абстрактным. В общем работал с тем что есть.
"""


"""
Привет, дорогой друг! Давай разбираться что можно улучшить в твоей работе.
Ниже будут два вида комментариев:
- первый (!) - это критической замечание, надо исправлять!
- второй (*) - это приятное улучшение, как задание со звёздочкой, не критично, но клёво! (:
- третий (**) - это высшая лига, считай для олимпиадников!

Если возникнут вопросы или сложности после прочтения комментарие,
то не стесняйся пиши, разберёмся вместе (:

Общие замечание:
(!)
    Форматирование и соотвествие PEP-8, уверен тебе рассказывали зачем это нужно.
    Есть live-hack, если ты пользуешься PyCharm, то можешь не закапываться
    в этот скучный PEP-8, потому что есть специальная команда Code->Reformat Code,
    которая приведёт код в порядок. Не в 100% reformat отрабывает ОК,
    но обычно этого достаточно. Со временем набьёшь руку и со всеми
    правилами познакомишься. Ниже как раз пример твоего кода, пропущенный через
    эту функциональность, обрати внимание как красово стало! Ляпота! (:
(!)
    Почему нет тестов? Видел что знакомились с pytest. Нужны тесты,
    без тестов принять не могу. Например есть опечатки в коде которые приводят к
    критическим багам, если будут тесты может еще что-то всплывёт.
    Тесты не только ускоряют разработку и делает код готовым к продакшену,
    но и поднимают твою ценность в глаза работадателя.
    Разработчики которые умееют писать тесты ценяться дороже и им легче найти работу ;)
(**)
    Есть кстати даже отдельная методика написание кода через тесты,
    называется Test Driven Development, можешь глянуть.
(*)
    Отсутсвует конструкция if __name__ == '__main__', если планируешь запускать
    модуль отдельно, то желательно добавить.
(+)
    У тебя достаточно всё хорошо с названием переменных, функций и методов. Это многого стоит,
    так держать!!!
"""

import datetime as dt
import json
"""
(*)
    А используется ли ниже import json и если нет, то зачем он?
    Иногда импорты позволяют быстро понять что делает модуль и
    с чем он работает - это часть документации. Здесь как с кодом,
    не используется - удали и не путай коллег. При этом импорт требует времени.
    Кстати в PyCharm есть комманда optimize imports, которая не просто
    убирает не нужное, но и еще в правильно порядке всё расставляет. 
"""


class Record:
    def __init__(self, amount, comment, date=''):
        self.amount = amount
        self.date = dt.datetime.now().date() if not date else dt.datetime.strptime(date, '%d.%m.%Y').date()
        self.comment = comment
    """
    (*)
        self.date = dt.datetime.now().date() if not date else dt.datetime.strptime(date, '%d.%m.%Y').date()
        Строка достаточно длинная, более 79 символов, так требует PEP,
        но предлагаю тебе не паниковать из-за длинных строк, иногда без них никаках.
        Это скорее рекомендации, которая заставляет тебя думать как написать понятней.
        Здесь другая сложность, есть дополнительная логика в else
        в виде преобразование строки в дату. Используй однострочники для совсем 
        простых вещей. Здесь лучше так:
            
            if not date:
                self.date = dt.datetime.now().date()
            else:
                self.date = dt.datetime.strptime(date, '%d.%m.%Y').date()

        Можешь кстати глянуть вот эту статью (одна страница) про простой код
        и почему не всегда круто использовать те же длинные однострочники:
        https://habr.com/ru/post/347166/
    (**)
        Уверен, ты видел мемы про то, что пользователи тупые? На самом деле
        пользователи - это самое важно что у нас есть и их надо любить!
        Но правда в том, что часто по незнанию они могут ломать программы.
        Что будет если пользователь введёт дату не в формате %d.%m.%Y?
        Программа сломается и пользователь будет расстроен? В однострочном if
        врядли что-то уже сделать, но в исправленном варианте есть место для манёвра.
    (**)
        Кстати в init стараются держать минимум логики, если будешь обрабатывать кейс выше,
        то можно подумать над тем, как обработку исключений или валидацию вынести из init.
    (**)
        C amount так же проблема как с датой, дальше он будет участвовать в суммирование
        и поломать Calculator. Тема с amount в виде int и типизации касается
        программирования по контракту, тема не простая, но очень полезная.
        Пока же добавляй хотя бы аннотации, будет уже лучше!

            def __init__(self, amount: int, comment: str, date=None):
    """


class Calculator:
    def __init__(self, limit):
        self.limit = limit
        self.records = []

    """
    (*)
        И еще раз, хочешь облегчить коллегам жизнь, добавляей аннотации:
            def __init__(self, limit: int):
    (**)
        Крутые хакермены часто обозначают что не следует трогать извне.
        Например, records хранит определённый тип данных и на нём завязано много логики.
        Ощущение, что records должен меняться только методами класса и его лучше не менять
        "вручную", иначе можно всё сломать. В таких кейсах помогают приватные свойста и методы.
        Это отдельная тема, но можно сделать так:

            def __init__(self, limit):
                self._records = []
        
            @property
            def records(self):
                return self._records
        
        Свойство 'records' чтобы проще было обращаться.    
    """

    def add_record(self, record):
        self.records.append(record)
    """
    (!)
        Почему здесь аннотация более важная (!), чем при limit (*)? Здесь не просто число,
        здесь требуется объект класса Record, при этом сам класс может лежать в другом модуле.
        Может быть сложно для понимания о чём идет речь, поэтому либо аннотация,
        либо комментарий.

            def add_record(self, record: Record):
    """

    def get_today_stats(self):
        today_stats = 0
        for Record in self.records:
            if Record.date == dt.datetime.now().date():
                today_stats = today_stats + Record.amount
        return today_stats
    """
    (!)
        Воу-воу! Это shadow naming! Это самая опасная штука на свете! O_O
        Record - это класс, но здесь мы его переопределяем и это становится
        элементом self.records, а это уже instance класса Record.
        Ниже строчки `for Record in self.records:` не получится создать Record.
        За пределами метода всё будет хорошо, но шанс отсрелить себе ногу очень высок.
        Чтобы понять почему Record переопределиться только в рамках метода можешь
        глянуть про python namespaces, python variable scope и 
        Local, Global, Built-in, Enclosed.
    """

    def get_week_stats(self):
        week_stats = 0
        today = dt.datetime.now().date()
        for record in self.records:
            if (today - record.date).days < 7 and (today - record.date).days >= 0:
                week_stats += record.amount
        return week_stats
    """
    (*)
        Зачем два раза вычислять дату, она же одинаковая? Это ресурсоёмко.
            (today - record.date).days < 7 and (today - record.date).days >= 0
        
        Можно вычислить до условия, а еще python поддерживает конструкции типа: 
            if A <= my_magic_variable < B:
                ...

    (**)
        Что произойдет с кодом, если понадобиться добавить get_stats
        за 3 дня, 10 дней и месяц? Да и вообще за любой период? (:
        У тебя есть get_today_stats и get_week_stats, но по факту у них практически
        одинаковая функциональность, может её можно вынести? Далее из этих методов
        просто вызывать некую универсальную штуку которая считает статистику за любой период.
        
        О таких вещах важно думать, о том что может еще добавить со временем, но здесь
        важно найти баланс, чтобы не усложнить систему. Если считаешь что такая
        функциональность не пригодится или понимаешь что рефакторинг будет
        не ресурсоёмкий, то можно и не делать. Крутые разработчики всегда об этом думают. 
    """


class CaloriesCalculator(Calculator):
    def get_calories_remained(self):  # Получает остаток калорий на сегодня
        x = self.limit - self.get_today_stats()
        if x > 0:
            return f'Сегодня можно съесть что-нибудь ещё, но с общей калорийностью не более {x} кКал'
        else:
            return 'Хватит есть!'
    """
    (*)
        По комментарию смотри кейс ниже для USD_RATE, здесь же
        обычно коментарий засовывают внутри функции, например вот так:
            
            def get_calories_remained(self):
                # My magic comment
    (*)
        Классический кейс, зачем else, если после return функция закончит свой выполнение?
    """


class CashCalculator(Calculator):
    USD_RATE = float(60)  # Курс доллар США.
    EURO_RATE = float(70)  # Курс Евро.
    """
    (*)
        Почему float(60) и float(70), чем это будет отличаться от просто 60.0 и 70.0?
        >>> type(float(60)) == type(60.0)
            True
    (*)
        Не пиши комменратий ради комментария, старайся писать самодокументирующийся код.
        Очень многие страдают тем, что пишут комментарии потому что их надо писать,
        но нужен ли комментарий `Курс доллар США.` возле `USD_RATE`?
        Коментарии дополняет код там, где возникают вопросы, если название переменной
        кристально ясно, то и коментарий не нужен (:
        Пробуй найти эту границу когда коментарий нужен и когда он лиший и является шумом.
    (*)
        Вижу что по ТЗ USD_RATE и EURO_RATE должны быть здесь, но обычно
        курсы валют глобальные на весь проект, их выносят отдельно или есть отдельный
        механиз по их 'достованию'. Уточню почему ребята из практикума так написали
        и отпишусь тебе точно (:
    """
    def get_today_cash_remained(self, currency, USD_RATE=USD_RATE, EURO_RATE=EURO_RATE):
        """
        (!)
            Опять shadow naming в USD_RATE и EURO_RATE!
            Считай что только что мы выстрелили себе во вторую ногу :D

                def get_today_cash_remained(self, currency, USD_RATE=USD_RATE, EURO_RATE=EURO_RATE):

            надо не только переименовать и подумать почему здесь большими буквали переменные?
            Они точно должны быть большие, может всё-таки просто как usd_rate?
        """
        currency_type = currency
        cash_remained = self.limit - self.get_today_stats()
        if currency == 'usd':
            cash_remained /= USD_RATE
            currency_type = 'USD'
        elif currency_type == 'eur':
            cash_remained /= EURO_RATE
            currency_type = 'Euro'
        elif currency_type == 'rub':
            cash_remained == 1.00
            currency_type = 'руб'
            """
            (!)
                Здесь опечатка `cash_remained == 1.00`.
                Автоматические тесты позволяют такие кейсы легко отследить.
                Запустил и всё само проверилость - это реально экономит время!
            """

        if cash_remained > 0:
            return f'На сегодня осталось {round(cash_remained, 2)} {currency_type}'
        elif cash_remained == 0:
            return 'Денег нет, держись'
        elif cash_remained < 0:
            return 'Денег нет, держись: твой долг - {0:.2f} {1}'.format(-cash_remained, currency_type)
        """
        (!)
            Что произойдет если пользователь передаст неизвестную валюту,
            например он опечатается и написал uds вместое usd? То что вернётся - это то что
            ты хотел вернуть, когда писал метод?
        (*)
            Старайся ничего не вычислять в строках, плохой тон, выноси отдельно:
                round(cash_remained, 2)
                f'На сегодня осталось {round(cash_remained, 2)} {currency_type}'
        (*)
            Зачем здесь elif когда есть return? Оставляй просто if.
        (**)    
            Последний if можно убрать, ведь если мы прошли > 0 и == 0,
            то понятно что cash_remained < 0. Иногда такие условия оставляют
            для ясности кода, но думаю тут можно этим пожертвовать.
 
        (*)
            f строки тоже поддерживают форматирование как и format, поэтому можешь
            смело их использовать вместо format:
    
                'Денег нет, держись: твой долг - {0:.2f} {1}'.format(-cash_remained, currency_type)
            
            Если ты вынесешь round(cash_remained, 2) отдельно, то такой проблемы
            вообще не будет, просто подставляешь в строку (:
        (**)
            Здесь два больших блока с if, но как их протестировать по отдельности?
            Если тебе знаком Single Responsibility Principle (если нет, оставляей как есть),
            то предлагаю тебе подумать как можно этот большой метод распилить и
            сделать отдельные методы для каждой из зон отвественности.
            Так можно будет очень легко протестировать и у каждого блока будет своё имя,
            помнишь про самодокументирующейся код и комментарии?
            Еще и поддерживать будет проще.
        """

    def get_week_stats(self):
        super().get_week_stats()
        """
            (!)
                Если не переопределять метод, то что произойдёт и метод какого класа будет вызван?
                Поменяется что-то или нет если переопределение метода убрать?
    
                Это замечательный кейс для автотестов, если есть тест которые проверяют
                данную функциональность и нет уверенности в том, как работает super,
                то можно просто удалить данный метод, запустить и посмотреть
                проходят тесты или нет. Тесты для рефакторига - это превосходно!
                Удалил, запустил и через секунду знаешь работает или нет!
        """
